//
//  UIViewController+AlertView.m
//  Objctive_AssociatedObjects
//
//  Created by xuran on 16/3/25.
//  Copyright © 2016年 X.R. All rights reserved.
//

/**
 *  Objective-C Runtime 实战 为UIViewController挂载(也叫关联)对象属性，封装AlertView，使用起来更加友好方便.
 *
 *  个人理解：Runtime 是苹果公司用C语言开发的一种可以让Objective-C为类动态添加属性，动态添加方法和动态替换方法，可以在运行时动态
 *  检测某个属性是否存在的一种运行时库。
 *
 *  1. 那么runtime到底是什么？！
 *
 *  Objective-C runtime是一个实现Objective-C语言的C库。runtime用C语言中的结构体表示对象，用C函数实现方法(methods)，且额外的添加了一些属性。
 *  这些函数和结构体被runtime函数封装后，使得Objective-C语言在程序运行时可以对对象和类，以及它们的方法，进行动态的创建，修改，检查。除了封装外，
 *  Objective-C runtime库也负责找出程序最终执行代码， 也就是说当程序执行到[objct doSomethings]的方法时，并不会直接找到方法然后调用，而是当
 *  一条消息发送给一个对象时，Objective-C中的方法调用其实就是消息的发送，消息发送给要响应改消息的对象（消息接收者），runtime库会提供一个机会让对象
 *  根据消息决定应该作出什么样的反应。
 *
 *  2. runtime到底能做什么？！
 *
 *  @1. 在KVC中的setValue中使用，在KVC中在使用setValue: forKey:方法对对象的属性赋值时，如果某个属性不存在，也就是key不存在时，就会crash。
 *      那么，使用runtime在setValue: forKey:之前检测是否有这个属性，便可以防止程序的crash。
 *  @2. 动态创建函数，有时候会根据项目需求动态的创建函数。
 *  @3. 替换已有的函数，当在混合编码时不能按照已有的思路执行程序，我们可以通过runtime替换掉已有的函数。
 *  @4. 动态的挂载(也叫关联)对象，当我们想为某个类添加关联对象属性时，runtime完全可以做到。下拉刷新，上拉加载库使用的就是这种方法。
 */

#import "UIViewController+AlertView.h"
#import <objc/runtime.h>

static const char* xr_alertViewAssociationKey = "xr_alertViewAssociationKey";
static const char* xr_complationBlockAssociationKey = "xr_complationBlockAssociationKey";

@interface UIViewController ()<UIAlertViewDelegate>

@property (strong, nonatomic) UIAlertView * alertView;
@property (copy,   nonatomic) void (^complationBlock) (NSInteger buttonIndex);

@end

@implementation UIViewController (AlertView)

// runtime getter
- (UIAlertView *)alertView {
    
    return objc_getAssociatedObject(self, &xr_alertViewAssociationKey);
}

// runtime setter
- (void)setAlertView:(UIAlertView *)alertView {
    
    objc_setAssociatedObject(self, &xr_alertViewAssociationKey, alertView, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

- (void (^)(NSInteger))complationBlock {
    
    return objc_getAssociatedObject(self, &xr_complationBlockAssociationKey);
}

- (void)setComplationBlock:(void (^)(NSInteger))complationBlock {
    
    objc_setAssociatedObject(self, &xr_complationBlockAssociationKey, complationBlock, OBJC_ASSOCIATION_COPY_NONATOMIC);
}

// show Alert
- (void)showAlertWithTitle:(NSString *)title message:(NSString *)message cancelButtonTitle:(NSString *)cancleTitle completion:(void (^)(NSInteger buttonIndex))completion otherButtonTitles:(NSString *)otherTitles, ...NS_REQUIRES_NIL_TERMINATION {
    
    self.alertView = [[UIAlertView alloc] initWithTitle:title message:message delegate:self cancelButtonTitle:cancleTitle otherButtonTitles:nil];
    
    // 不定参数列表
    va_list args;
    va_start(args, otherTitles);
    
    if (otherTitles) {
        
        [self.alertView addButtonWithTitle:otherTitles];
        
        NSString * otherString;
        while ( (otherString = va_arg(args, NSString *)) ) {
            
            [self.alertView addButtonWithTitle:otherString];
        }
    }
    
    va_end(args);
    
    self.complationBlock = [completion copy];
    [self.alertView show];
}

#pragma mark - UIAlertViewDelegate

- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex {
    
    if (self.complationBlock) {
        self.complationBlock(buttonIndex);
    }
}

@end
